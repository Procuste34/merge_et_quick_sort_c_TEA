\documentclass[11pt]{article}
\usepackage{geometry}                % See geometry.pdf to learn the layout
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}

\title{Compte-rendu du TEA n°3}
\author{\textsc{Valentin GAUTHIER}\\ Alexandre TORRES--LEGUET}

\begin{document}
\maketitle

\section{Introduction}
%présentation du problème, le contexte

\quad \quad Ce compte-rendu présente le travail réalisé dans le cadre du TEA 3 de l'enseignement d'AAP, qui se concentre sur le tri rapide et le tri fusion en \textsc{C}.
 
Nous avons vu en TD le principe de fonctionnement et le code de ces tris en \textsc{C}, notre tâche a alors été dans un premier temps d'adapter ce travail afin de le rendre compatible avec les outils de création de graphiques, i.e. avec la structure de données \texttt{T\textunderscore data}. 

Dans un second temps, nous avons implémenté les fonctions \texttt{fusionsort} et \texttt{quicksort} qui respectent le même prototype que la fonction \texttt{qsort} disponible nativement dans \textsc{C}. (sous réserve d'inclure \texttt{stdlib.h})

Enfin, nous avons implémenter le tri fusion sur des listes chaînées.



\section{Développement}
%organisation du programme
%organisation du groupe (qui a fait quoi)
%difficultés

\quad \quad Dans le déroulé de notre travail, il s’est tout d’abord agit de revoir le cours en profondeur pour s’assurer de maîtriser les nouvelles définitions de types, structures et manières d’implémenter sous \textsc{C} pour plus d’efficacité lors de la réalisation pratique. Cette phase de théorie aura durée l’ensemble du weekend (26 et 27/11). Ensuite, Alexandre s’est chargé de rédigé un premier code en \textsc{Python} pour se faire une première idée de l'algorithme proposé. Puis le lundi 28/11, nous nous sommes réunis pour décider des fichiers et exercices à disposition dans le TP que nous pouvions utiliser (intégralement, en partie ou plus ou moins modifié) pour le TEA. L’après midi du lundi aura suffit pour que nous codions les fonctions nécessaires pour la partie 1 du TEA . Sur cette partie Alexandre s’est chargé des fichiers \texttt{rpn.c} et \texttt{rpn.h}, et Valentin s’est lui occupé de la modification des fichiers \texttt{elt.c} et \texttt{elt.h}.

Puis pour la partie 2, nous nous sommes réunies rapidement mardi pour décider qui ferait quelle partie (implémentation de \texttt{rec.c} ou de \texttt{main.c}) et pour discuter de nos premières idées sur les fonctions. Alexandre est donc partie sur la réalisation de la fonction de recherche en profondeur et Valentin le fichier \texttt{main.c}. Nous avons décider de réaliser ce travail le soir même pour s’assurer d’avoir le temps de corriger les erreurs le lendemain, avant la remise du TEA.

Nous avons rencontré quelques difficultés lors de la manipulation des chaînes de caractères, notamment pour la concaténation (nécessaire lors du parcours en profondeur) ou encore pour convertir des nombres en chaîne de caractère ou vice-versa. Egalement, il a fallu s'accorder sur les conventions prises lors de la Partie 1 (que renvoie \texttt{rpn\textunderscore eval} en cas d'une RPN non valide ? comment le détecter ? etc...) pour effectuer la Partie 2 puisque cette seconde partie se base sur les fonctions développées dans la première.

Un autre point de discussion important a été celui de la représentation des cartons restants. Nous avons au départ penser à utiliser une liste, mais nous nous sommes rendus compte par la suite que avoir accès qu'à l'élément en tête de liste allait rendre inutilement compliqué la boucle à faire sur les cartons restants. Nous avons donc décidé de passer, lors des appels récursifs, un tableau d'entiers ainsi que la longueur de ce tableau.

\section{Résultats}
%présentation des résultats, jeux d'essais, analyse, temps d'exec...

Voici, pour 2 jeux d'essais, les temps d'exécutions constatés sur l'une de nos machines (par moyenne).
Le premier exemple correspond à une cible parfaite, tandis que le second ne peut qu'être approché, d'où la longueur de l'exécution.

\begin{center}
\begin{tabular}{||c c c||} 
 \hline
 cartons & cible & temps \\ [0.5ex] 
 \hline\hline
 3 5 7 9 25 50 & 788 & 1.2s \\ 
 \hline
 2 2 3 4 6 10 & 631 & 23.6s \\ [1ex] 
\hline
\end{tabular}
\end{center}

Il est intéressant de remarquer que ces temps d'exécutions sont bien meilleurs que ceux constatés avec notre implémentation \textsc{Python}.

\section{Schéma d'exploration}

Notre algorithme, étant donné un RPN, cherche à lui ajouter un à un tous les opérateurs, puis un à un les cartons restants.
Une amélioration que nous avons effectué est que, si jamais un RPN peut être évalué sous forme d'une valeur (exemple : $1 \; 2 \; +$ qui peut être évalué à $3$) alors lui ajouter un opérateur le rendra nécessairement invalide. Sur le schéma, on voit que cette amélioration évite l'exploration inutile d'un grand nombre de noeuds de l'arbre.


\section{Conclusion}
%analyser les problèmes, perspectives

\quad \quad Au terme du travail, il vient que notre programme semble fonctionner grâce à plusieurs tests tous réalisés avec justesse. Nous restons conscients que c'est un algorithme de type "glouton".

\end{document}  
